<!DOCTYPE html>
<html lang="en">
   <head>
      <title>3D Game of Life using Three.js</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
      <style> body { margin: 0; } </style>
   </head>
   <body>
<script type="importmap"> {
   "imports": { "three": "../build/three.module.js" }
} </script>   
<script type="module">   
import * as THREE from 'three';
import { OrbitControls } from '../examples/jsm/controls/OrbitControls.js';

let camera, scene, renderer, controls, torus;

// Torus parameters
let radius = 2,
    tubeSize = 1,
    radialSegments = 24,
    tubularSegments = 48,
    tubeColor = 0xFFCC99;

// Life grid resolution
const hres = tubularSegments; // around main ring
const vres = radialSegments;  // around tube

// Colors
const gridColor    = 0x808080;
const cellOnColor  = 0x000000; // ON = black
const cellOffColor = 0xffffff; // OFF = white

// Initial random fill ratio
const initialFill = 0.25;

// State
let cellState = [];     // [x][y] = 0/1
let nextState = [];     // next generation   [x][y] = 0/1
let colorAttr;          // BufferAttribute for vertex colors
let onRGB, offRGB;      // [r,g,b] arrays

// Animation / control
const stepsPerSecond = 4;
let lastStepTime = 0;

init();
create();

// --------------------------------------------------
// INIT
// --------------------------------------------------
function init() {
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setClearColor(0x4D4D4D);
  document.body.appendChild(renderer.domElement);
  renderer.setAnimationLoop(animate);
  window.addEventListener('resize', onWindowResize);

  camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.set(0, 0, 10);

  scene = new THREE.Scene();
  scene.add(new THREE.AxesHelper(0.5));
  scene.add(
    new THREE.PolarGridHelper(3 * radius, 4 * radialSegments, 3 * radius, radialSegments)
  );

  controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 0, 0);
  controls.update();

  // Precompute RGB arrays for ON/OFF
  const onColor  = new THREE.Color(cellOnColor);
  const offColor = new THREE.Color(cellOffColor);
  onRGB  = [onColor.r,  onColor.g,  onColor.b ];
  offRGB = [offColor.r, offColor.g, offColor.b];
}

// --------------------------------------------------
// MODELING (Torus + Life grid)
// --------------------------------------------------
function create() {
  // 1) Indexed torus geometry
  let geometry = new THREE.TorusGeometry(
    radius,
    tubeSize,
    radialSegments,
    tubularSegments
  );

  // Number of logical cells
  const cellCount = tubularSegments * radialSegments;

  // 2) Convert to non-indexed so each triangle has its own vertices
  geometry = geometry.toNonIndexed();

  const vertexCount = geometry.attributes.position.count;

  // 3) Add vertex color attribute
  const colors = new Float32Array(vertexCount * 3);
  colorAttr = new THREE.BufferAttribute(colors, 3);
  geometry.setAttribute('color', colorAttr);

  // Initialize all vertices to OFF color
  for (let i = 0; i < vertexCount; i++) {
    colors[3 * i + 0] = offRGB[0];
    colors[3 * i + 1] = offRGB[1];
    colors[3 * i + 2] = offRGB[2];
  }
  colorAttr.needsUpdate = true;

  // 4) Create torus mesh using vertex colors
  const material = new THREE.MeshBasicMaterial({
    vertexColors: true,
    side: THREE.DoubleSide
  });

  torus = new THREE.Mesh(geometry, material);
  torus.rotation.x = Math.PI / 2;
  scene.add(torus);

  // 5) Draw grid lines
  draw_grid(torus);

  // 6) Initialize logical state + random fill
  initCells();
  rancells(initialFill);
}

// Draw wireframe grid
function draw_grid(torus) {
  const edges = new THREE.EdgesGeometry(torus.geometry, 0.001); // include all rings
  const gridMat = new THREE.LineBasicMaterial({
    color: gridColor,
    depthTest: true,
    polygonOffset: true,
    polygonOffsetFactor: -1,
    polygonOffsetUnits: -1
  });
  const gridLines = new THREE.LineSegments(edges, gridMat);
  torus.add(gridLines);
}

// --------------------------------------------------
// STATE INITIALIZATION
// --------------------------------------------------
function initCells() {
  cellState = new Array(hres);
  nextState = new Array(hres);
  for (let x = 0; x < hres; x++) {
    cellState[x] = new Array(vres);
    nextState[x] = new Array(vres);
    for (let y = 0; y < vres; y++) {
      cellState[x][y] = 0;
      nextState[x][y] = 0;
    }
  }
}

// --------------------------------------------------
// draw_cell, rancells, stepLife
// --------------------------------------------------

// Each cell (x,y) corresponds to 6 vertices:
// cellIndex = y * hres + x
// vertices: 6*cellIndex .. 6*cellIndex + 5
function draw_cell(x, y, on = true) {
  const cellIndex = y * hres + x;
  const start = cellIndex * 6;
  const rgb = on ? onRGB : offRGB;

  for (let i = 0; i < 6; i++) {
    const vi = start + i;
    colorAttr.setX(vi, rgb[0]);
    colorAttr.setY(vi, rgb[1]);
    colorAttr.setZ(vi, rgb[2]);
  }
  colorAttr.needsUpdate = true;
  cellState[x][y] = on ? 1 : 0;
}

// Randomly set cells ON/OFF
function rancells(percentage) {
  const p = THREE.MathUtils.clamp(percentage, 0, 1);
  for (let x = 0; x < hres; x++) {
    for (let y = 0; y < vres; y++) {
      const isOn = Math.random() < p;
      draw_cell(x, y, isOn);
    }
  }
}

// Count live neighbors with torus wrap-around
function countNeighbors(x, y) {
  let count = 0;
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      if (dx === 0 && dy === 0) continue; // skip self
      const nx = (x + dx + hres) % hres;
      const ny = (y + dy + vres) % vres;
      count += cellState[nx][ny];
    }
  }
  return count;
}

// One Game-of-Life step (B3/S23) on the torus
function stepLife() {
  // Compute nextState from cellState
  for (let x = 0; x < hres; x++) {
    for (let y = 0; y < vres; y++) {
      const alive = cellState[x][y] === 1;
      const n = countNeighbors(x, y);

      let nextAlive = alive;
      if (alive) {
        // Survival: 2 or 3 neighbors
        nextAlive = (n === 2 || n === 3);
      } else {
        // Birth: exactly 3 neighbors
        nextAlive = (n === 3);
      }
      nextState[x][y] = nextAlive ? 1 : 0;
    }
  }

  // Swap arrays and update colors
  for (let x = 0; x < hres; x++) {
    for (let y = 0; y < vres; y++) {
      const v = nextState[x][y] === 1;
      draw_cell(x, y, v);
    }
  }
}

// --------------------------------------------------
// RENDER
// --------------------------------------------------
function animate(time) {
  // time is in ms, provided by setAnimationLoop
  if (time - lastStepTime > 1000 / stepsPerSecond) {
    stepLife();
    lastStepTime = time;
  }

  controls.update();
  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
   </body>
</html>
