<!DOCTYPE html>
<html lang="en">
   <head>
      <title>3D Game of Life using Three.js</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
      <style> body { margin: 0; } </style>
   </head>
   <body>
<script type="importmap"> {
   "imports": { "three": "../build/three.module.js" }
} </script>   
<script type="module">   
import * as THREE from 'three';
import { OrbitControls } from '../examples/jsm/controls/OrbitControls.js';

let camera, scene, renderer, controls, torus;

// Torus parameters
let radius = 2,
    tubeSize = 1,
    radialSegments = 24,
    tubularSegments = 48,
    tubeColor = 0xFFCC99;

// Life grid resolution
const hres = tubularSegments; // around main ring
const vres = radialSegments;  // around tube

// Colors
const gridColor    = 0x808080;
const cellOnColor  = 0x000000; // ON = black
const cellOffColor = 0xffffff; // OFF = white;

// Life parameters
const initialFill     = 0.25;  // initial random density
const stepsPerSecond  = 4;     // Life update rate
const altitudeStep    = 0.03;  // altitude increase per generation
let   altitudeEnabled = true;  // default: altitude ON

// State
let cellState = [];   // [x][y] = 0/1 (alive/dead)
let nextState = [];   // [x][y] = 0/1 (for next generation)
let cellAge   = [];   // [x][y] = integer age (consecutive alive steps)
let nextAge   = [];   // [x][y] = next generation age

// Geometry attributes
let colorAttr;        // BufferAttribute for vertex colors
let positionAttr;     // BufferAttribute for positions
let normalAttr;       // BufferAttribute for normals
let basePositions;    // copy of original positions
let baseNormals;      // copy of original normals
let onRGB, offRGB;    // [r,g,b]

// Animation / control
let lastStepTime = 0;
let paused       = false;

// Pattern placement
const patternSpread = 6; // max offset around last pattern center
let lastPatternKey    = null;
let lastPatternCenter = null;

// Life patterns
const patterns = {
  '1': {
    name: 'Blinker',
    width: 3,
    height: 1,
    cells: [
      [0, 0], [1, 0], [2, 0]
    ]
  },
  '2': {
    name: 'Beacon',
    width: 4,
    height: 4,
    cells: [
      [0,0],[1,0],[0,1],[1,1],
      [2,2],[3,2],[2,3],[3,3]
    ]
  },
  '3': {
    name: 'Glider',
    width: 3,
    height: 3,
    cells: [
      [1,0],
      [2,1],
      [0,2],[1,2],[2,2]
    ]
  },
  '4': {
    name: 'Toad',
    width: 4,
    height: 2,
    cells: [
      [1,0],[2,0],[3,0],
      [0,1],[1,1],[2,1]
    ]
  },
  '5': {
    name: 'Beehive',
    width: 4,
    height: 3,
    cells: [
      [1,0],[2,0],
      [0,1],[3,1],
      [1,2],[2,2]
    ]
  },
};

init();
create();
window.addEventListener('keydown', onKeyDown);

// --------------------------------------------------
// INIT
// --------------------------------------------------
function init() {
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setClearColor(0x4D4D4D);
  document.body.appendChild(renderer.domElement);
  renderer.setAnimationLoop(animate);
  window.addEventListener('resize', onWindowResize);

  camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.set(0, 0, 10);

  scene = new THREE.Scene();
  scene.add(new THREE.AxesHelper(0.5));
  scene.add(
    new THREE.PolarGridHelper(3 * radius, 4 * radialSegments, 3 * radius, radialSegments)
  );

  controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 0, 0);
  controls.update();

  const onColor  = new THREE.Color(cellOnColor);
  const offColor = new THREE.Color(cellOffColor);
  onRGB  = [onColor.r,  onColor.g,  onColor.b ];
  offRGB = [offColor.r, offColor.g, offColor.b];
}

// --------------------------------------------------
// MODELING (Torus + Life grid)
// --------------------------------------------------
function create() {
  // 1) Indexed torus geometry
  let geometry = new THREE.TorusGeometry(
    radius,
    tubeSize,
    radialSegments,
    tubularSegments
  );

  // 2) Convert to non-indexed so each triangle has its own vertices
  geometry = geometry.toNonIndexed();
  geometry.computeVertexNormals();

  positionAttr = geometry.attributes.position;
  normalAttr   = geometry.attributes.normal;
  const vertexCount = positionAttr.count;
  const cellCount   = tubularSegments * radialSegments;

  // 3) Copy base positions/normals for altitude storage
  basePositions = new Float32Array(positionAttr.array);
  baseNormals   = new Float32Array(normalAttr.array);

  // 4) Add vertex color attribute
  const colors = new Float32Array(vertexCount * 3);
  colorAttr = new THREE.BufferAttribute(colors, 3);
  geometry.setAttribute('color', colorAttr);

  // Initialize all vertices to OFF color
  for (let i = 0; i < vertexCount; i++) {
    colors[3 * i + 0] = offRGB[0];
    colors[3 * i + 1] = offRGB[1];
    colors[3 * i + 2] = offRGB[2];
  }
  colorAttr.needsUpdate = true;

  // 5) Torus mesh
  const material = new THREE.MeshBasicMaterial({
    vertexColors: true,
    side: THREE.DoubleSide
  });

  torus = new THREE.Mesh(geometry, material);
  torus.rotation.x = Math.PI / 2;
  scene.add(torus);

  // 5) Draw grid lines
  draw_grid(torus);

  // 7) Life state + random init
  initCells();
  rancells(initialFill);
}

// Draw wireframe grid
function draw_grid(torus) {
  const edges = new THREE.EdgesGeometry(torus.geometry, 0.001); // include all rings
  const gridMat = new THREE.LineBasicMaterial({
    color: gridColor,
    depthTest: true,
    polygonOffset: true,
    polygonOffsetFactor: -1,
    polygonOffsetUnits: -1
  });
  const gridLines = new THREE.LineSegments(edges, gridMat);
  torus.add(gridLines);
}

// --------------------------------------------------
// STATE INITIALIZATION
// --------------------------------------------------
function initCells() {
  cellState = new Array(hres);
  nextState = new Array(hres);
  cellAge   = new Array(hres);
  nextAge   = new Array(hres);

  for (let x = 0; x < hres; x++) {
    cellState[x] = new Array(vres);
    nextState[x] = new Array(vres);
    cellAge[x]   = new Array(vres);
    nextAge[x]   = new Array(vres);
    for (let y = 0; y < vres; y++) {
      cellState[x][y] = 0;
      nextState[x][y] = 0;
      cellAge[x][y]   = 0;
      nextAge[x][y]   = 0;
    }
  }
}

// --------------------------------------------------
// CELL VISUAL / ALTITUDE
// --------------------------------------------------
function applyCellVisual(x, y) {
  const cellIndex = y * hres + x;
  const start = cellIndex * 6;
  const alive = cellState[x][y] === 1;
  const rgb   = alive ? onRGB : offRGB;

  // Color
  for (let i = 0; i < 6; i++) {
    const vi = start + i;
    colorAttr.setX(vi, rgb[0]);
    colorAttr.setY(vi, rgb[1]);
    colorAttr.setZ(vi, rgb[2]);
  }
  colorAttr.needsUpdate = true;

  // Altitude
  const age = cellAge[x][y];
  let height = 0;
  if (altitudeEnabled && alive) {
    height = age * altitudeStep;
  }

  for (let i = 0; i < 6; i++) {
    const vi = start + i;

    const bx = basePositions[3 * vi + 0];
    const by = basePositions[3 * vi + 1];
    const bz = basePositions[3 * vi + 2];

    const nx = baseNormals[3 * vi + 0];
    const ny = baseNormals[3 * vi + 1];
    const nz = baseNormals[3 * vi + 2];

    positionAttr.setX(vi, bx + height * nx);
    positionAttr.setY(vi, by + height * ny);
    positionAttr.setZ(vi, bz + height * nz);
  }
  positionAttr.needsUpdate = true;
}

// helper: update whole grid visuals (e.g. after toggling altitude)
function updateAllCellsVisual() {
  for (let x = 0; x < hres; x++) {
    for (let y = 0; y < vres; y++) {
      applyCellVisual(x, y);
    }
  }
}

// Set a cell's logical state + age + visuals
function setCellState(x, y, alive, ageVal) {
  cellState[x][y] = alive ? 1 : 0;
  cellAge[x][y]   = alive ? Math.max(ageVal, 1) : 0;
  applyCellVisual(x, y);
}

// --------------------------------------------------
// draw_cell, rancells, neighbors, stepLife
// --------------------------------------------------
function draw_cell(x, y, on = true) {
  setCellState(x, y, !!on, on ? cellAge[x][y] || 1 : 0);
}

// Randomly set cells ON/OFF
function rancells(percentage) {
  const p = THREE.MathUtils.clamp(percentage, 0, 1);
  for (let x = 0; x < hres; x++) {
    for (let y = 0; y < vres; y++) {
      const isOn = Math.random() < p;
      const ageVal = isOn ? 1 : 0;
      setCellState(x, y, isOn, ageVal);
    }
  }
}

// Count neighbors on torus (wrap-around)
function countNeighbors(x, y) {
  let count = 0;
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      if (dx === 0 && dy === 0) continue;
      const nx = (x + dx + hres) % hres;
      const ny = (y + dy + vres) % vres;
      count += cellState[nx][ny];
    }
  }
  return count;
}

// One Life step (B3/S23) + age update + altitude growth
function stepLife() {
  // Compute nextState & nextAge
  for (let x = 0; x < hres; x++) {
    for (let y = 0; y < vres; y++) {
      const alive = cellState[x][y] === 1;
      const n     = countNeighbors(x, y);

      let newAlive;
      if (alive) {
        // survival: 2 or 3 neighbors
        newAlive = (n === 2 || n === 3);
      } else {
        // birth: exactly 3 neighbors
        newAlive = (n === 3);
      }

      nextState[x][y] = newAlive ? 1 : 0;

      if (newAlive) {
        nextAge[x][y] = alive ? (cellAge[x][y] + 1) : 1;
      } else {
        nextAge[x][y] = 0;
      }
    }
  }

  // Apply nextState/nextAge + update visuals
  for (let x = 0; x < hres; x++) {
    for (let y = 0; y < vres; y++) {
      const alive = nextState[x][y] === 1;
      const ageVal = nextAge[x][y];
      setCellState(x, y, alive, ageVal);
    }
  }
}

// --------------------------------------------------
// KEYBOARD CONTROLS
// --------------------------------------------------
function onKeyDown(event) {
  const key = event.key;

  switch (key) {
    case 'p':
    case 'P':
      paused = !paused;
      break;

    case 's':
    case 'S':
      if (paused) {
        stepLife();
      }
      break;

    case 'c':
    case 'C':
      clearGrid();
      break;

    case 'r':
    case 'R':
      rancells(initialFill);
      break;

    case 'a':
    case 'A':
      altitudeEnabled = !altitudeEnabled;
      updateAllCellsVisual();
      break;

    // Pattern keys
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
      if (paused) {
        placePattern(key);
      }
      break;

    default:
      break;
  }
}

function clearGrid() {
  for (let x = 0; x < hres; x++) {
    for (let y = 0; y < vres; y++) {
      setCellState(x, y, false, 0);
    }
  }
  lastPatternKey = null;
  lastPatternCenter = null;
}

function placePattern(key) {
  const pattern = patterns[key];
  if (!pattern) return;

  let cx, cy;

  if (lastPatternKey === key && lastPatternCenter) {
    // Place near the previous center
    const dx = THREE.MathUtils.randInt(-patternSpread, patternSpread);
    const dy = THREE.MathUtils.randInt(-patternSpread, patternSpread);
    cx = (lastPatternCenter.x + dx + hres) % hres;
    cy = (lastPatternCenter.y + dy + vres) % vres;
  } else {
    // First time for this key: center of grid
    cx = Math.floor(hres / 2);
    cy = Math.floor(vres / 2);
  }

  // Adjust so pattern is centered at (cx, cy)
  const originX = cx - Math.floor(pattern.width  / 2);
  const originY = cy - Math.floor(pattern.height / 2);

  for (const [px, py] of pattern.cells) {
    const x = (originX + px + hres) % hres;
    const y = (originY + py + vres) % vres;
    setCellState(x, y, true, 1);
  }

  lastPatternKey = key;
  lastPatternCenter = { x: cx, y: cy };
}

// --------------------------------------------------
// RENDER
// --------------------------------------------------
function animate(time) {
  if (!paused && (time - lastStepTime > 1000 / stepsPerSecond)) {
    stepLife();
    lastStepTime = time;
  }

  controls.update();
  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
   </body>
</html>
